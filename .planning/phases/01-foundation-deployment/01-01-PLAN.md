---
phase: 01-foundation-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .gitignore
  - .env.example
  - src/config/env.ts
  - src/lib/logger.ts
autonomous: true

must_haves:
  truths:
    - "Bun project initializes with all dependencies installed"
    - "TypeScript strict mode is enforced with no any allowed"
    - "Environment variables are validated through Zod schema at startup"
    - "Logger provides debug/info/warn/error levels with LOG_LEVEL filtering"
  artifacts:
    - path: "package.json"
      provides: "Project definition with @clack/prompts and zod dependencies"
      contains: "@clack/prompts"
    - path: "tsconfig.json"
      provides: "Strict TypeScript configuration for Bun"
      contains: "strict"
    - path: ".gitignore"
      provides: "Git ignore rules for node_modules, .env, dist"
      contains: "node_modules"
    - path: ".env.example"
      provides: "Template showing all required environment variables"
      contains: "ANTHROPIC_API_KEY"
    - path: "src/config/env.ts"
      provides: "Zod schema validation and typed config export"
      exports: ["env", "Env", "envSchema"]
    - path: "src/lib/logger.ts"
      provides: "Thin logging wrapper with level filtering"
      exports: ["logger"]
  key_links:
    - from: "src/config/env.ts"
      to: "Bun.env"
      via: "Zod safeParse"
      pattern: "envSchema\\.safeParse"
    - from: "src/lib/logger.ts"
      to: "Bun.env.LOG_LEVEL"
      via: "level threshold check"
      pattern: "LOG_LEVEL"
---

<objective>
Initialize the Rachel8 Bun/TypeScript project with strict typing, install all dependencies, create the environment configuration module with Zod validation, and build a thin logging wrapper. This establishes the foundation that every subsequent plan and phase builds on.

Purpose: All future code depends on the project structure, typed config, and logger existing first.
Output: A working Bun project with `bun install` succeeding, config validation ready, and logger importable.
</objective>

<execution_context>
@/Users/lory/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lory/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-deployment/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Bun project with dependencies and TypeScript config</name>
  <files>
    package.json
    tsconfig.json
    .gitignore
    .env.example
  </files>
  <action>
Create the project foundation files:

**package.json:**
- name: "rachel8", type: "module"
- Scripts: "start": "bun run src/index.ts", "dev": "bun --watch run src/index.ts", "setup": "bun run src/setup/wizard.ts", "test": "bun test"
- Dependencies: @clack/prompts, zod
- Dev dependencies: @types/bun
- Run `bun install` to generate bun.lock

**tsconfig.json** (per research, from Bun docs):
- compilerOptions: lib: ["ESNext"], target: "ESNext", module: "Preserve", moduleDetection: "force"
- Bundler mode: moduleResolution: "bundler", allowImportingTsExtensions: true, verbatimModuleSyntax: true, noEmit: true
- Strict mode (user decision): strict: true, skipLibCheck: true, noFallthroughCasesInSwitch: true, noUncheckedIndexedAccess: true, noImplicitOverride: true, noUnusedLocals: true, noUnusedParameters: true, noPropertyAccessFromIndexSignature: true
- include: ["src/**/*.ts"]

**.gitignore:**
- node_modules/, .env, dist/, *.log, .DS_Store, bun.lock (if desired, but usually committed)

**.env.example** (template with empty values and comments):
```
# Rachel8 Configuration
# Run 'bun run setup' to fill these values interactively

# Anthropic Claude API key (https://console.anthropic.com/settings/keys)
ANTHROPIC_API_KEY=

# Telegram Bot Token (from @BotFather on Telegram)
TELEGRAM_BOT_TOKEN=

# Exa API key (https://dashboard.exa.ai/api-keys)
EXA_API_KEY=

# Path to shared Obsidian vault folder
SHARED_FOLDER_PATH=

# Environment (development | production | test)
NODE_ENV=production

# Log level (debug | info | warn | error)
LOG_LEVEL=info
```

Create the source directory structure: src/config/, src/setup/, src/cli/, src/lib/
  </action>
  <verify>
Run `bun install` — exits 0, node_modules exists, bun.lock generated.
Run `bun run tsc --noEmit` or `bunx tsc --noEmit` — no TypeScript errors (will need at least one .ts file, handled by Task 2).
Verify .env.example contains all 6 variables.
  </verify>
  <done>
package.json has correct scripts and dependencies. tsconfig.json enforces strict mode. .gitignore excludes .env and node_modules. .env.example documents all required variables. `bun install` succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod environment config module and logger</name>
  <files>
    src/config/env.ts
    src/lib/logger.ts
  </files>
  <action>
**src/config/env.ts:**
Create the centralized configuration module using Zod. This is the single source of truth for all environment variables — no code should access Bun.env or process.env directly.

- Define `envSchema` using z.object():
  - ANTHROPIC_API_KEY: z.string().startsWith("sk-ant-") with descriptive error
  - TELEGRAM_BOT_TOKEN: z.string().regex(/^\d{8,}:[A-Za-z0-9_-]{35,}$/) with descriptive error
  - EXA_API_KEY: z.string().min(10) with descriptive error
  - SHARED_FOLDER_PATH: z.string().min(1)
  - NODE_ENV: z.enum(["development", "production", "test"]).default("production")
  - LOG_LEVEL: z.enum(["debug", "info", "warn", "error"]).default("info")
- Export `type Env = z.infer<typeof envSchema>`
- Create `loadEnv()` function that:
  1. First checks if .env file exists using `Bun.file(".env").size` or similar. If not, prints friendly message: "No .env file found. Run the setup wizard: bun run setup" and exits with code 0 (not 1, to prevent systemd restart loops — per research pitfall 6)
  2. Runs envSchema.safeParse(Bun.env)
  3. On failure: prints each validation error with field name and message, suggests running setup wizard, exits with code 1
  4. On success: returns validated Env object
- Export `const env: Env = loadEnv()` for direct import
- Also export envSchema for use by the setup wizard's validation

**src/lib/logger.ts:**
Create a thin logging wrapper (per discretion recommendation from research):

- Define LogLevel type: "debug" | "info" | "warn" | "error"
- Define LEVELS record mapping level names to numeric values (debug=0, info=1, warn=2, error=3)
- Read current level from process.env.LOG_LEVEL (use process.env here, NOT the env config — logger loads before config validation and must not create circular dependency)
- Default to "info" if LOG_LEVEL not set
- Export `logger` object with debug(), info(), warn(), error() methods
- Each method: check shouldLog(level), then call appropriate console method
- Format: `[LEVEL] message` with optional context object
- Do NOT add timestamps — journalctl adds them automatically when running as systemd service
  </action>
  <verify>
Run `bunx tsc --noEmit` — no TypeScript errors.
Create a temporary test: import { envSchema } from "./src/config/env.ts" and verify it's a Zod object.
Create a temporary test: import { logger } from "./src/lib/logger.ts" and verify logger.info("test") outputs to console.
  </verify>
  <done>
src/config/env.ts exports envSchema, Env type, and env constant. loadEnv() checks for .env existence before validation, prints friendly errors, exits 0 when .env missing. src/lib/logger.ts exports logger with 4 levels, respects LOG_LEVEL, no external dependencies. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `bun install` completes successfully
2. `bunx tsc --noEmit` reports no errors
3. Directory structure exists: src/config/, src/setup/, src/cli/, src/lib/
4. .env.example has all 6 required variables with helpful comments
5. env.ts Zod schema matches .env.example variables exactly
6. Logger outputs at correct levels based on LOG_LEVEL
</verification>

<success_criteria>
- `bun install` exits 0
- `bunx tsc --noEmit` exits 0
- Importing env.ts without .env present prints friendly setup message and exits 0
- Importing logger.ts and calling logger.info("hello") outputs "[INFO] hello"
- All files follow strict TypeScript (no any, explicit types)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-deployment/01-01-SUMMARY.md`
</output>
